--[[-----------------------------------------------------------------------------------------
    Fixed Aries UI Library Source
-------------------------------------------------------------------------------------------]]
local Library_Definition_Function = function()
    getgenv().namehub = "Arise" -- You can change "Arise" to your desired Hub Name
    local UserInputService = game:GetService('UserInputService')
    local LocalPlayer = game:GetService('Players').LocalPlayer
    local TweenService = game:GetService('TweenService')
    local HttpService = game:GetService('HttpService')
    local CoreGui = game:GetService('CoreGui')

    -- Guard against LocalPlayer not being available immediately
    if not LocalPlayer then
        warn("Aries Library: LocalPlayer not found at script initialization. Retrying...")
        repeat task.wait() until game:GetService('Players').LocalPlayer
        LocalPlayer = game:GetService('Players').LocalPlayer
        if not LocalPlayer then
            warn("Aries Library: LocalPlayer still not found. UI might not function correctly.")
            return nil -- Cannot proceed without LocalPlayer
        end
    end

    local Mouse = LocalPlayer:GetMouse()

    local Library = {
        connections = {};
        Flags = {};
        Enabled = true; -- UI starts enabled, thus should be visible
        slider_drag = false;
        core = nil;
        dragging = false;
        drag_position = nil;
        start_position = nil;
    }

    -- Ensure 'isfolder', 'makefolder', 'writefile', 'readfile' are available in getgenv or handle errors
    -- For example, wrapping them in pcall if they are not guaranteed.
    -- This example assumes they are globally available as per typical exploit environments.
    if not pcall(function() return isfolder("Aries hub") end) then
        warn("Aries Library: 'isfolder' function is not available or errored. File operations might fail.")
    elseif not isfolder("Aries hub") then
        local success, err = pcall(makefolder, "Aries hub")
        if not success then
            warn("Aries Library: Failed to create 'Aries hub' folder:", err)
        end
    end

    function Library:disconnect()
        for i, connection in pairs(Library.connections) do
            if connection then
                connection:Disconnect()
                Library.connections[i] = nil
            end
        end
    end

    function Library:clear()
        for _, object in pairs(CoreGui:GetChildren()) do
            if object.Name == "Aries" and object:IsA("ScreenGui") then
                object:Destroy()
            end
        end
    end

    function Library:exist()
        return Library.core and Library.core.Parent == CoreGui
    end

    function Library:save_flags()
        if not Library:exist() then return end
        local success, flags_json = pcall(HttpService.JSONEncode, HttpService, Library.Flags)
        if not success then
            warn("Aries Library: Failed to JSONEncode flags for saving:", flags_json)
            return
        end
        local write_success, write_err = pcall(writefile, `Aries hub/{game.GameId}.lua`, flags_json) -- FIXED PATH
        if not write_success then
            warn("Aries Library: Failed to write flags file:", write_err)
        end
    end

    function Library:load_flags()
        local path_exists, err_path = pcall(isfile, `Aries hub/{game.GameId}.lua`)
        if not path_exists then
            if err_path then warn("Aries Library: 'isfile' errored:", err_path) end
            Library:save_flags() -- Create file if it doesn't exist or isfile errored
            return
        end

        local flags_json, err_read = pcall(readfile, `Aries hub/{game.GameId}.lua`)
        if not flags_json then
            warn("Aries Library: Failed to read flags file:", err_read)
            Library:save_flags()
            return
        end

        local success, decoded_flags = pcall(HttpService.JSONDecode, HttpService, flags_json)
        if success then
            Library.Flags = decoded_flags
        else
            warn("Aries Library: Failed to JSONDecode flags, resetting flags:", decoded_flags)
            Library:save_flags() -- Save default flags if decoding failed
        end
    end

    Library.load_flags()
    Library.clear() -- Clear any previous instances

    function Library:open()
        if not Library.core then return end
        Library.core.Container.Visible = true
        Library.core.Shadow.Visible = true
        if Library.core:FindFirstChild("Mobile") then Library.core.Mobile.Modal = true end

        TweenService:Create(Library.core.Container, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
            Size = UDim2.new(0, 699, 0, 426)
        }):Play()

        TweenService:Create(Library.core.Shadow, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
            Size = UDim2.new(0, 776, 0, 509)
        }):Play()
    end

    function Library:close()
        if not Library.core then return end
        TweenService:Create(Library.core.Shadow, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
            Size = UDim2.new(0, 0, 0, 0)
        }):Play()

        local main_tween = TweenService:Create(Library.core.Container, TweenInfo.new(0.6, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut), {
            Size = UDim2.new(0, 0, 0, 0)
        })
        main_tween:Play()

        main_tween.Completed:Once(function()
            if Library.enabled or not Library.core then -- Check Library.core again in case it was destroyed
                return
            end
            Library.core.Container.Visible = false
            Library.core.Shadow.Visible = false
            if Library.core:FindFirstChild("Mobile") then Library.core.Mobile.Modal = false end
        end)
    end

    function Library:drag()
        if not Library.dragging or not Library.drag_position or not Library.start_position or not Library.core then
            return
        end
        
        local current_mouse_pos
        if self.input and self.input.Position then -- 'self' here is the table passed from InputChanged
            current_mouse_pos = self.input.Position
        else
            return -- Not enough info to drag
        end

        local delta = current_mouse_pos - Library.drag_position
        local position = UDim2.new(Library.start_position.X.Scale, Library.start_position.X.Offset + delta.X, Library.start_position.Y.Scale, Library.start_position.Y.Offset + delta.Y)

        -- Ensure the main container (Library.core) is the one being moved
        TweenService:Create(Library.core, TweenInfo.new(0.1), { -- Reduced tween time for responsiveness
            Position = position
        }):Play()
    end


    function Library:visible()
        if not Library.core then return end -- Ensure core UI exists
        Library.enabled = not Library.enabled

        if Library.enabled then
            Library.open(Library.core) -- Pass Library.core as self
        else
            Library.close(Library.core) -- Pass Library.core as self
        end
    end

    function Library:new()
        Library.clear() -- Clear previous UI just in case

        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "Aries"
        screenGui.Parent = CoreGui
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Helps manage layering if other UIs exist

        Library.core = screenGui -- screenGui is the main 'self' for open/close/drag

        local Shadow = Instance.new("ImageLabel")
        Shadow.Name = "Shadow"
        Shadow.Parent = screenGui -- Parent to screenGui
        Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        Shadow.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Shadow.BackgroundTransparency = 1.000
        Shadow.Position = UDim2.new(0.5, 0, 0.5, 0) -- Centered with screenGui
        Shadow.Size = UDim2.new(0, 776, 0, 509)
        Shadow.ZIndex = 1 -- Base ZIndex
        Shadow.Image = "rbxassetid://17290899982"
        Shadow.ImageColor3 = Color3.fromRGB(0,0,0) -- Make shadow black
        Shadow.ImageTransparency = 0.7 -- Make shadow more visible

        local Container = Instance.new("Frame")
        Container.Name = "Container"
        Container.Parent = screenGui -- Parent to screenGui
        Container.AnchorPoint = Vector2.new(0.5, 0.5)
        Container.BackgroundColor3 = Color3.fromRGB(19, 20, 24)
        Container.ClipsDescendants = true
        Container.Position = UDim2.new(0.5, 0, 0.5, 0) -- Centered with screenGui
        Container.Size = UDim2.new(0, 699, 0, 426)
        Container.ZIndex = 2 -- Above shadow

        local ContainerCorner = Instance.new("UICorner")
        ContainerCorner.CornerRadius = UDim.new(0, 20)
        ContainerCorner.Parent = Container

        local Top = Instance.new("ImageLabel")
        Top.Name = "Top"
        Top.Parent = Container
        Top.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Top.BackgroundTransparency = 1.000
        Top.Size = UDim2.new(1, 0, 0, 39) -- Use scale for width
        Top.ZIndex = 3

        local Logo = Instance.new("ImageLabel")
        Logo.Name = "Logo"
        Logo.Parent = Top
        Logo.AnchorPoint = Vector2.new(0, 0.5) -- Anchor to left
        Logo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Logo.BackgroundTransparency = 1.000
        Logo.Position = UDim2.new(0, 15, 0.5, 0) -- Position from left
        Logo.Size = UDim2.new(0, 30, 0, 25)
        Logo.Image = "rbxassetid://18424935697"
        Logo.ZIndex = 4

        local TitleLabel = Instance.new("TextLabel")
        TitleLabel.Name = "TitleLabel"
        TitleLabel.Parent = Top
        TitleLabel.AnchorPoint = Vector2.new(0, 0.5) -- Anchor to left
        TitleLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        TitleLabel.BackgroundTransparency = 1.000
        TitleLabel.Position = UDim2.new(0, 55, 0.5, 0) -- Position next to logo
        TitleLabel.Size = UDim2.new(0, 150, 0, 20) -- Adjusted size
        TitleLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
        TitleLabel.Text = getgenv().namehub
        TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        TitleLabel.TextScaled = true
        TitleLabel.TextSize = 14.000
        TitleLabel.TextWrapped = true
        TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
        TitleLabel.ZIndex = 4

        local Line = Instance.new("Frame")
        Line.Name = "Line"
        Line.Parent = Container
        Line.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
        Line.Position = UDim2.new(0.296, 0, 0.0915, 0) -- Relative positioning
        Line.Size = UDim2.new(0, 2, 0.9, -39) -- Relative height, accounting for top bar
        Line.ZIndex = 3


        local tabsScrollingFrame = Instance.new("ScrollingFrame")
        tabsScrollingFrame.Name = "Tabs"
        tabsScrollingFrame.Parent = Container
        tabsScrollingFrame.Active = true
        tabsScrollingFrame.BackgroundTransparency = 1.000
        tabsScrollingFrame.Position = UDim2.new(0, 0, 0.0915, 0) -- Below top bar
        tabsScrollingFrame.Size = UDim2.new(0.295, 0, 0.9085, 0) -- Fill left side
        tabsScrollingFrame.ScrollBarThickness = 0
        tabsScrollingFrame.ZIndex = 3

        local tabsListLayout = Instance.new("UIListLayout")
        tabsListLayout.Parent = tabsScrollingFrame
        tabsListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        tabsListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        tabsListLayout.Padding = UDim.new(0, 9)

        local tabsPadding = Instance.new("UIPadding")
        tabsPadding.Parent = tabsScrollingFrame
        tabsPadding.PaddingTop = UDim.new(0, 15)

        -- Drag functionality connections for the main container (screenGui)
        -- The Top bar is usually the drag handle.
        Top.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                Library.dragging = true
                Library.drag_position = input.Position
                Library.start_position = screenGui.Position -- Drag the ScreenGui itself

                local connection
                connection = input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        Library.dragging = false
                        Library.drag_position = nil
                        Library.start_position = nil
                        if connection then connection:Disconnect() end -- Disconnect this changed event
                    end
                end)
                table.insert(Library.connections, connection) -- Store for later disconnect
            end
        end)

        local inputChangedConnection = UserInputService.InputChanged:Connect(function(input)
            if Library.dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                Library.drag({ input = input }) -- Pass input object directly
            end
        end)
        table.insert(Library.connections, inputChangedConnection)

        local inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
            if gameProcessedEvent then return end
            if not Library:exist() then return end
            if input.KeyCode == Enum.KeyCode.Insert then
                Library.visible() -- Call directly on Library, it will use Library.core
            end
        end)
        table.insert(Library.connections, inputBeganConnection)
        
        -- Note: Mobile button was not fully implemented in example usage, simplified here
        -- If you need the mobile button, its connections and logic from the original lib should be reviewed.
        -- For now, the Insert key is the primary toggle.

        local Tab = {} -- This table will hold methods for creating tabs, elements etc.

        function Tab:create_tab(tab_display_name) -- FIXED: Added tab_display_name argument
            local tabButton = Instance.new("TextButton")
            tabButton.Name = "TabButton_" .. tab_display_name -- Unique name
            tabButton.Parent = tabsScrollingFrame
            tabButton.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
            tabButton.Size = UDim2.new(0, 174, 0, 40) -- Match example values
            tabButton.ZIndex = 4
            tabButton.AutoButtonColor = false
            tabButton.Text = "" -- Visuals handled by children

            local tabCorner = Instance.new("UICorner")
            tabCorner.CornerRadius = UDim.new(0, 5)
            tabCorner.Parent = tabButton

            local tabTextLabel = Instance.new("TextLabel")
            tabTextLabel.Name = "TextLabel"
            tabTextLabel.Parent = tabButton
            tabTextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
            tabTextLabel.BackgroundTransparency = 1.000
            tabTextLabel.Position = UDim2.new(0.589, 0, 0.5, 0) -- Adjusted for centering with icon
            tabTextLabel.Size = UDim2.new(0, 124, 0, 15)
            tabTextLabel.ZIndex = 5
            tabTextLabel.FontFace = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
            tabTextLabel.Text = tab_display_name -- FIXED: Use argument here
            tabTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            tabTextLabel.TextScaled = true
            tabTextLabel.TextTransparency = 0.300
            tabTextLabel.TextXAlignment = Enum.TextXAlignment.Left

            local tabLogo = Instance.new("ImageLabel")
            tabLogo.Name = "Logo"
            tabLogo.Parent = tabButton
            tabLogo.AnchorPoint = Vector2.new(0.5, 0.5)
            tabLogo.BackgroundTransparency = 1.000
            tabLogo.Position = UDim2.new(0.130, 0, 0.5, 0)
            tabLogo.Size = UDim2.new(0, 17, 0, 17)
            tabLogo.ZIndex = 5
            tabLogo.Image = "rbxassetid://17290697757" -- Placeholder icon, update if needed
            tabLogo.ImageTransparency = 0.300

            local tabGlow = Instance.new("ImageLabel") -- Selection glow/indicator
            tabGlow.Name = "Glow"
            tabGlow.Parent = tabButton
            tabGlow.AnchorPoint = Vector2.new(0.5, 0.5)
            tabGlow.BackgroundTransparency = 1.000
            tabGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
            tabGlow.Size = UDim2.new(0, 190, 0, 53)
            tabGlow.Image = "rbxassetid://17290723539"
            tabGlow.ImageTransparency = 1.000 -- Hidden by default
            tabGlow.ZIndex = 3 -- Behind text/logo

            local tabFill = Instance.new("Frame") -- Selection fill
            tabFill.Name = "Fill"
            tabFill.Parent = tabButton
            tabFill.AnchorPoint = Vector2.new(0.5, 0.5)
            tabFill.BackgroundTransparency = 1.000 -- Hidden by default
            tabFill.Position = UDim2.new(0.5, 0, 0.5, 0)
            tabFill.Size = UDim2.new(1, 0, 1, 0)
            tabFill.ZIndex = 2 -- Behind glow
            local fillCorner = Instance.new("UICorner")
            fillCorner.CornerRadius = UDim.new(0, 10)
            fillCorner.Parent = tabFill
            local fillGradient = Instance.new("UIGradient")
            fillGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(66, 89, 182)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(37, 57, 137))}
            fillGradient.Rotation = 20
            fillGradient.Parent = tabFill

            local leftSection = Instance.new("ScrollingFrame")
            leftSection.Name = "LeftSection_" .. tab_display_name
            leftSection.Parent = Container
            leftSection.Active = true
            leftSection.BackgroundTransparency = 1.000
            leftSection.Position = UDim2.new(0.326, 0, 0.0915, 0) -- Position to the right of tabs list
            leftSection.Size = UDim2.new(0.32, 0, 0.9085, 0)     -- Adjust size to fit
            leftSection.AutomaticCanvasSize = Enum.AutomaticSize.Y
            leftSection.ScrollBarThickness = 4
            leftSection.Visible = false -- Hide sections by default, show for active tab
            leftSection.ZIndex = 3
            local leftListLayout = Instance.new("UIListLayout")
            leftListLayout.Parent = leftSection
            leftListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            leftListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            leftListLayout.Padding = UDim.new(0, 7)
            Instance.new("UIPadding", leftListLayout).PaddingTop = UDim.new(0,5)


            local rightSection = Instance.new("ScrollingFrame")
            rightSection.Name = "RightSection_" .. tab_display_name
            rightSection.Parent = Container
            rightSection.Active = true
            rightSection.BackgroundTransparency = 1.000
            rightSection.Position = UDim2.new(0.662, 0, 0.0915, 0) -- Position to the right of left section
            rightSection.Size = UDim2.new(0.32, 0, 0.9085, 0)    -- Adjust size to fit
            rightSection.AutomaticCanvasSize = Enum.AutomaticSize.Y
            rightSection.ScrollBarThickness = 4
            rightSection.Visible = false -- Hide sections by default
            rightSection.ZIndex = 3
            local rightListLayout = Instance.new("UIListLayout")
            rightListLayout.Parent = rightSection
            rightListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            rightListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            rightListLayout.Padding = UDim.new(0, 7)
            Instance.new("UIPadding", rightListLayout).PaddingTop = UDim.new(0,5)


            local function switch_to_this_tab()
                -- Hide all other sections
                for _, child in ipairs(Container:GetChildren()) do
                    if child:IsA("ScrollingFrame") and (child.Name:find("LeftSection_") or child.Name:find("RightSection_")) then
                        child.Visible = false
                    end
                    if child:IsA("TextButton") and child.Name:find("TabButton_") then -- Reset other tabs
                        if child:FindFirstChild("Fill") then child.Fill.BackgroundTransparency = 1 end
                        if child:FindFirstChild("Glow") then child.Glow.ImageTransparency = 1 end
                        if child:FindFirstChild("TextLabel") then child.TextLabel.TextTransparency = 0.3 end
                        if child:FindFirstChild("Logo") then child.Logo.ImageTransparency = 0.3 end
                    end
                end
                -- Show this tab's sections
                leftSection.Visible = true
                rightSection.Visible = true
                -- Highlight this tab
                tabFill.BackgroundTransparency = 0
                tabGlow.ImageTransparency = 0
                tabTextLabel.TextTransparency = 0
                tabLogo.ImageTransparency = 0
            end
            
            if #tabsScrollingFrame:GetChildren() == 1 then -- If this is the first tab
                switch_to_this_tab()
            end

            tabButton.MouseButton1Click:Connect(switch_to_this_tab)
            table.insert(Library.connections, tabButton.MouseButton1Click)


            local Module = {} -- This will be the returned object for the specific tab

            function Module:create_toggle(options)
                local parent_section = options.section == "left" and leftSection or rightSection
                -- ... (Toggle creation logic from original library, adapted to use 'options' and 'parent_section')
                -- Example structure for toggle:
                local toggleButton = Instance.new("TextButton")
                toggleButton.Name = options.name
                toggleButton.Parent = parent_section
                toggleButton.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
                toggleButton.Size = UDim2.new(0.9, 0, 0, 37) -- Use scale for width within section
                toggleButton.Text = "" -- Visuals handled by children
                Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0,10)

                local toggleLabel = Instance.new("TextLabel")
                toggleLabel.Parent = toggleButton
                toggleLabel.BackgroundTransparency = 1
                toggleLabel.Size = UDim2.new(0.8, -25, 1, 0) -- Make space for checkbox
                toggleLabel.Position = UDim2.new(0, 5, 0, 0)
                toggleLabel.Font = Enum.Font.GothamSemibold
                toggleLabel.Text = options.name
                toggleLabel.TextColor3 = Color3.fromRGB(255,255,255)
                toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
                toggleLabel.TextScaled = true

                local checkboxFrame = Instance.new("Frame")
                checkboxFrame.Parent = toggleButton
                checkboxFrame.AnchorPoint = Vector2.new(1, 0.5)
                checkboxFrame.Position = UDim2.new(1, -5, 0.5, 0)
                checkboxFrame.Size = UDim2.new(0, 17, 0, 17)
                checkboxFrame.BackgroundColor3 = Color3.fromRGB(22,23,27)
                Instance.new("UICorner", checkboxFrame).CornerRadius = UDim.new(0,4)

                local checkboxFill = Instance.new("Frame", checkboxFrame)
                checkboxFill.AnchorPoint = Vector2.new(0.5,0.5)
                checkboxFill.Position = UDim2.new(0.5,0,0.5,0)
                checkboxFill.Size = UDim2.new(1,0,1,0)
                Instance.new("UICorner", checkboxFill).CornerRadius = UDim.new(0,4)
                local fillGradient = Instance.new("UIGradient", checkboxFill)
                fillGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(66, 89, 182)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(37, 57, 137))}
                fillGradient.Rotation = 20
                
                local checkboxGlow = Instance.new("ImageLabel", checkboxFrame) -- Copied from library
                checkboxGlow.Name = "Glow"
                checkboxGlow.AnchorPoint = Vector2.new(0.5, 0.5)
                checkboxGlow.BackgroundTransparency = 1.000
                checkboxGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
                checkboxGlow.Size = UDim2.new(0, 27, 0, 27) -- Larger for glow effect
                checkboxGlow.Image = "rbxassetid://17290798394"
                checkboxGlow.ImageTransparency = 1.000 -- Hidden by default
                checkboxGlow.ZIndex = checkboxFrame.ZIndex -1

                local current_state = Library.Flags[options.flag]
                if current_state == nil then current_state = options.enabled or false end
                Library.Flags[options.flag] = current_state

                local function update_visual(state)
                    checkboxFill.Visible = state
                    checkboxGlow.ImageTransparency = state and 0 or 1
                end
                update_visual(current_state)
                if options.callback then pcall(options.callback, current_state) end


                toggleButton.MouseButton1Click:Connect(function()
                    Library.Flags[options.flag] = not Library.Flags[options.flag]
                    update_visual(Library.Flags[options.flag])
                    if options.callback then pcall(options.callback, Library.Flags[options.flag]) end
                    Library:save_flags()
                end)
                table.insert(Library.connections, toggleButton.MouseButton1Click)
                return toggleButton -- Or a module representing the toggle if needed
            end

            function Module:create_slider(options)
                local parent_section = options.section == "left" and leftSection or rightSection
                -- ... (Slider creation logic, adapted)
                local sliderFrame = Instance.new("TextButton") -- Using TextButton as base like toggle for consistency
                sliderFrame.Name = options.name
                sliderFrame.Parent = parent_section
                sliderFrame.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
                sliderFrame.Size = UDim2.new(0.9, 0, 0, 48)
                Instance.new("UICorner", sliderFrame).CornerRadius = UDim.new(0,10)
                sliderFrame.Text = ""

                local sliderLabel = Instance.new("TextLabel", sliderFrame)
                sliderLabel.BackgroundTransparency = 1
                sliderLabel.Position = UDim2.new(0,10,0,5)
                sliderLabel.Size = UDim2.new(0.7, -10, 0, 15)
                sliderLabel.Font = Enum.Font.GothamSemibold
                sliderLabel.Text = options.name
                sliderLabel.TextColor3 = Color3.fromRGB(255,255,255)
                sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
                sliderLabel.TextScaled = true

                local valueLabel = Instance.new("TextLabel", sliderFrame)
                valueLabel.Name = "Number" -- As per original library for update_slider
                valueLabel.BackgroundTransparency = 1
                valueLabel.AnchorPoint = Vector2.new(1,0)
                valueLabel.Position = UDim2.new(1, -10, 0, 5)
                valueLabel.Size = UDim2.new(0.3, 0, 0, 15)
                valueLabel.Font = Enum.Font.GothamSemibold
                valueLabel.TextColor3 = Color3.fromRGB(255,255,255)
                valueLabel.TextXAlignment = Enum.TextXAlignment.Right
                valueLabel.TextScaled = true
                
                local sliderTrack = Instance.new("Frame", sliderFrame)
                sliderTrack.Name = "Box" -- As per original library
                sliderTrack.AnchorPoint = Vector2.new(0.5, 0)
                sliderTrack.Position = UDim2.new(0.5, 0, 0, 25) -- Below labels
                sliderTrack.Size = UDim2.new(0.9, 0, 0, 6)
                sliderTrack.BackgroundColor3 = Color3.fromRGB(22,23,27)
                Instance.new("UICorner", sliderTrack).CornerRadius = UDim.new(0,15)

                local sliderFill = Instance.new("ImageLabel", sliderTrack) -- Copied structure
                sliderFill.Name = "Fill"
                sliderFill.AnchorPoint = Vector2.new(0, 0.5)
                sliderFill.Position = UDim2.new(0,0,0.5,0)
                sliderFill.Size = UDim2.new(0,0,1,0) -- Width set by value
                sliderFill.Image = "rbxassetid://17382033116" -- From original
                Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(0,4)
                local fillGradient = Instance.new("UIGradient", sliderFill) -- Copied from original
                fillGradient.Name = "UIGradient" -- For transparency update
                fillGradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0.00, 0.00), NumberSequenceKeypoint.new(1.00, 0.00)}


                local sliderGlow = Instance.new("ImageLabel", sliderTrack) -- Copied structure
                sliderGlow.Name = "Glow"
                sliderGlow.AnchorPoint = Vector2.new(0.5,0.5)
                sliderGlow.Position = UDim2.new(0.5,0,0.5,0)
                sliderGlow.Size = UDim2.new(1, 12, 1, 11) -- Slightly larger than track
                sliderGlow.Image = "rbxassetid://17381990533" -- From original
                sliderGlow.ImageTransparency = 1 -- Default hidden
                sliderGlow.ZIndex = sliderTrack.ZIndex - 1
                local glowGradient = Instance.new("UIGradient", sliderGlow) -- Copied from original
                glowGradient.Name = "UIGradient" -- For transparency update
                glowGradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0.00, 0.00), NumberSequenceKeypoint.new(1.00, 0.00)}


                local current_value = Library.Flags[options.flag]
                if current_value == nil then current_value = options.value or options.minimum_value or 0 end
                current_value = math.clamp(current_value, options.minimum_value, options.maximum_value)
                Library.Flags[options.flag] = current_value

                local function update_slider_visuals(val)
                    local percentage = (val - options.minimum_value) / (options.maximum_value - options.minimum_value)
                    percentage = math.clamp(percentage, 0, 1)
                    sliderFill.Size = UDim2.new(percentage, 0, 1, 0)
                    valueLabel.Text = tostring(math.floor(val))

                    -- Update gradient transparencies for fill and glow based on percentage (from original lib logic)
                    local slider_size_clamped = math.clamp(percentage, 0.001, 0.999)
                    fillGradient.Transparency = NumberSequence.new({
                        NumberSequenceKeypoint.new(0, 0),
                        NumberSequenceKeypoint.new(slider_size_clamped, 0),
                        NumberSequenceKeypoint.new(math.min(slider_size_clamped + 0.001, 1), 1),
                        NumberSequenceKeypoint.new(1, 1)
                    })
                    glowGradient.Transparency = NumberSequence.new({
                        NumberSequenceKeypoint.new(0, 0),
                        NumberSequenceKeypoint.new(slider_size_clamped, 0),
                        NumberSequenceKeypoint.new(math.min(slider_size_clamped + 0.03, 1), 1),
                        NumberSequenceKeypoint.new(1, 1)
                    })
                end
                
                update_slider_visuals(current_value)
                if options.callback then pcall(options.callback, current_value) end

                local sliderHitbox = Instance.new("TextButton", sliderTrack) -- Hitbox for dragging
                sliderHitbox.Name = "Hitbox"
                sliderHitbox.Size = UDim2.new(1,0,2,0) -- Make it taller for easier clicking
                sliderHitbox.Position = UDim2.new(0.5,0,0.5,0)
                sliderHitbox.AnchorPoint = Vector2.new(0.5,0.5)
                sliderHitbox.BackgroundTransparency = 1
                sliderHitbox.Text = ""
                sliderHitbox.ZIndex = sliderTrack.ZIndex + 1


                local function on_drag(inputPos)
                    local relativeX = inputPos.X - sliderTrack.AbsolutePosition.X
                    local percentage = math.clamp(relativeX / sliderTrack.AbsoluteSize.X, 0, 1)
                    local new_value = options.minimum_value + (options.maximum_value - options.minimum_value) * percentage
                    new_value = math.floor(math.clamp(new_value, options.minimum_value, options.maximum_value))
                    
                    if Library.Flags[options.flag] ~= new_value then
                        Library.Flags[options.flag] = new_value
                        update_slider_visuals(new_value)
                        if options.callback then pcall(options.callback, new_value) end
                    end
                end

                sliderHitbox.MouseButton1Down:Connect(function()
                    Library.slider_drag = sliderFrame -- Store which slider is being dragged
                    on_drag(Mouse) -- Initial update on click
                end)
                table.insert(Library.connections, sliderHitbox.MouseButton1Down)
                
                -- MouseButton1Up and MouseMove on UserInputService to handle dragging
                -- These are simplified from the original library's loop approach for clarity
            end
            
            local sliderMoveConnection, sliderUpConnection
            sliderMoveConnection = UserInputService.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement and Library.slider_drag then
                     -- Find the correct slider options to pass to on_drag
                    local activeSliderOptions
                    for _, child in ipairs(leftSection:GetChildren()) do if child == Library.slider_drag then activeSliderOptions = options; break; end end
                    if not activeSliderOptions then
                         for _, child in ipairs(rightSection:GetChildren()) do if child == Library.slider_drag then activeSliderOptions = options; break; end end
                    end
                    if activeSliderOptions and Library.slider_drag:IsA("GuiObject") and Library.slider_drag:FindFirstChild("Box") then
                        local track = Library.slider_drag.Box
                        local relativeX = Mouse.X - track.AbsolutePosition.X
                        local percentage = math.clamp(relativeX / track.AbsoluteSize.X, 0, 1)
                        local new_value = activeSliderOptions.minimum_value + (activeSliderOptions.maximum_value - activeSliderOptions.minimum_value) * percentage
                        new_value = math.floor(math.clamp(new_value, activeSliderOptions.minimum_value, activeSliderOptions.maximum_value))
                        
                        if Library.Flags[activeSliderOptions.flag] ~= new_value then
                            Library.Flags[activeSliderOptions.flag] = new_value
                            -- Manually find and call update_slider_visuals for the active slider
                            valueLabel.Text = tostring(new_value)
                            local fill = Library.slider_drag.Box.Fill
                            fill.Size = UDim2.new(percentage, 0, 1, 0)
                            -- TODO: Re-implement gradient updates if needed here, or call a specific update function for that slider
                            if activeSliderOptions.callback then pcall(activeSliderOptions.callback, new_value) end
                        end
                    end
                end
            end)
            table.insert(Library.connections, sliderMoveConnection)

            sliderUpConnection = UserInputService.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    if Library.slider_drag then
                        Library.slider_drag = false
                        Library:save_flags()
                    end
                end
            end)
            table.insert(Library.connections, sliderUpConnection)


            function Module:create_dropdown(options)
                local parent_section = options.section == "left" and leftSection or rightSection
                -- ... (Dropdown creation logic, adapted)
                -- This is a more complex component, simplified for this example
                local dropdownButton = Instance.new("TextButton")
                dropdownButton.Name = options.name
                dropdownButton.Parent = parent_section
                dropdownButton.BackgroundColor3 = Color3.fromRGB(27, 28, 33)
                dropdownButton.Size = UDim2.new(0.9, 0, 0, 36)
                Instance.new("UICorner", dropdownButton).CornerRadius = UDim.new(0,10)
                
                local currentSelectionLabel = Instance.new("TextLabel", dropdownButton)
                currentSelectionLabel.BackgroundTransparency = 1
                currentSelectionLabel.Size = UDim2.new(1, -30, 1, 0) -- Space for arrow
                currentSelectionLabel.Position = UDim2.new(0,10,0,0)
                currentSelectionLabel.Font = Enum.Font.GothamSemibold
                currentSelectionLabel.TextColor3 = Color3.fromRGB(255,255,255)
                currentSelectionLabel.TextXAlignment = Enum.TextXAlignment.Left
                currentSelectionLabel.TextScaled = true

                local arrowLabel = Instance.new("TextLabel", dropdownButton)
                arrowLabel.BackgroundTransparency = 1
                arrowLabel.AnchorPoint = Vector2.new(1,0.5)
                arrowLabel.Position = UDim2.new(1,-5,0.5,0)
                arrowLabel.Size = UDim2.new(0,15,0,15)
                arrowLabel.Font = Enum.Font.GothamSemibold
                arrowLabel.TextColor3 = Color3.fromRGB(255,255,255)
                arrowLabel.Text = "▼" -- Down arrow

                local optionsFrame = Instance.new("ScrollingFrame", dropdownButton)
                optionsFrame.BackgroundTransparency = 0.2
                optionsFrame.BackgroundColor3 = Color3.fromRGB(22,23,27)
                optionsFrame.Position = UDim2.new(0,0,1,2) -- Below button
                optionsFrame.Size = UDim2.new(1,0,0,0) -- Height expands
                optionsFrame.Visible = false
                optionsFrame.ZIndex = dropdownButton.ZIndex + 10 -- Ensure it's on top
                Instance.new("UICorner", optionsFrame).CornerRadius = UDim.new(0,6)
                local optionsListLayout = Instance.new("UIListLayout", optionsFrame)
                optionsListLayout.Padding = UDim.new(0,2)


                local current_opt = Library.Flags[options.flag]
                if not current_opt or not table.find(options.options, current_opt) then
                    current_opt = options.option or (options.options and options.options[1])
                end
                Library.Flags[options.flag] = current_opt
                currentSelectionLabel.Text = options.name .. ": " .. tostring(current_opt)
                if options.callback then pcall(options.callback, current_opt) end

                local function toggle_options_frame()
                    optionsFrame.Visible = not optionsFrame.Visible
                    arrowLabel.Text = optionsFrame.Visible and "▲" or "▼"
                    if optionsFrame.Visible then
                        local totalHeight = 0
                        for _, child in ipairs(optionsFrame:GetChildren()) do
                            if child:IsA("TextButton") then totalHeight = totalHeight + child.AbsoluteSize.Y + optionsListLayout.Padding.Offset end
                        end
                        optionsFrame.CanvasSize = UDim2.new(0,0,0, totalHeight)
                        optionsFrame.Size = UDim2.new(1,0,0, math.min(totalHeight, 150)) -- Max height
                    else
                        optionsFrame.Size = UDim2.new(1,0,0,0)
                    end
                end

                for _, opt_val in ipairs(options.options) do
                    local optionButton = Instance.new("TextButton", optionsFrame)
                    optionButton.Size = UDim2.new(1, -10, 0, 25)
                    optionButton.Position = UDim2.new(0.5,0,0,0)
                    optionButton.AnchorPoint = Vector2.new(0.5,0)
                    optionButton.Text = tostring(opt_val)
                    optionButton.Font = Enum.Font.GothamSemibold
                    optionButton.TextColor3 = Color3.fromRGB(220,220,220)
                    optionButton.BackgroundTransparency = 1
                    optionButton.MouseButton1Click:Connect(function()
                        Library.Flags[options.flag] = opt_val
                        currentSelectionLabel.Text = options.name .. ": " .. tostring(opt_val)
                        if options.callback then pcall(options.callback, opt_val) end
                        Library:save_flags()
                        toggle_options_frame() -- Close after selection
                    end)
                    table.insert(Library.connections, optionButton.MouseButton1Click)
                end

                dropdownButton.MouseButton1Click:Connect(toggle_options_frame)
                table.insert(Library.connections, dropdownButton.MouseButton1Click)
            end

            function Module:create_textbox(options)
                local parent_section = options.section == "left" and leftSection or rightSection
                -- ... (Textbox creation logic, adapted)
                local textboxContainer = Instance.new("Frame")
                textboxContainer.Name = options.name .. "_Container"
                textboxContainer.Parent = parent_section
                textboxContainer.BackgroundColor3 = Color3.fromRGB(27,28,33)
                textboxContainer.Size = UDim2.new(0.9,0,0,36)
                Instance.new("UICorner", textboxContainer).CornerRadius = UDim.new(0,10)

                local actualTextbox = Instance.new("TextBox", textboxContainer)
                actualTextbox.Size = UDim2.new(1,-10,1,-10)
                actualTextbox.Position = UDim2.new(0.5,0,0.5,0)
                actualTextbox.AnchorPoint = Vector2.new(0.5,0.5)
                actualTextbox.BackgroundColor3 = Color3.fromRGB(22,23,27)
                actualTextbox.Font = Enum.Font.GothamSemibold
                actualTextbox.TextColor3 = Color3.fromRGB(255,255,255)
                actualTextbox.PlaceholderText = options.name
                Instance.new("UICorner", actualTextbox).CornerRadius = UDim.new(0,6)

                local current_text = Library.Flags[options.flag]
                if current_text == nil then current_text = options.value or "" end
                actualTextbox.Text = current_text
                Library.Flags[options.flag] = current_text
                if options.callback then pcall(options.callback, current_text) end

                actualTextbox.FocusLost:Connect(function(enterPressed)
                    if Library.Flags[options.flag] ~= actualTextbox.Text then
                        Library.Flags[options.flag] = actualTextbox.Text
                        if options.callback then pcall(options.callback, actualTextbox.Text) end
                        Library:save_flags()
                    end
                end)
                table.insert(Library.connections, actualTextbox.FocusLost)
            end

            function Module:create_keybind(options)
                local parent_section = options.section == "left" and leftSection or rightSection
                -- ... (Keybind creation logic, adapted)
                local keybindButton = Instance.new("TextButton")
                keybindButton.Name = options.name
                keybindButton.Parent = parent_section
                keybindButton.BackgroundColor3 = Color3.fromRGB(27,28,33)
                keybindButton.Size = UDim2.new(0.9,0,0,37)
                Instance.new("UICorner", keybindButton).CornerRadius = UDim.new(0,10)
                
                local keybindLabel = Instance.new("TextLabel", keybindButton)
                keybindLabel.BackgroundTransparency = 1
                keybindLabel.Size = UDim2.new(0.7,0,1,0)
                keybindLabel.Position = UDim2.new(0,5,0,0)
                keybindLabel.Font = Enum.Font.GothamSemibold
                keybindLabel.Text = options.name
                keybindLabel.TextColor3 = Color3.fromRGB(255,255,255)
                keybindLabel.TextXAlignment = Enum.TextXAlignment.Left
                keybindLabel.TextScaled = true

                local currentKeyLabel = Instance.new("TextButton", keybindButton) -- TextButton to show it's clickable
                currentKeyLabel.AnchorPoint = Vector2.new(1,0.5)
                currentKeyLabel.Position = UDim2.new(1,-5,0.5,0)
                currentKeyLabel.Size = UDim2.new(0.25,0,0.8,0)
                currentKeyLabel.BackgroundColor3 = Color3.fromRGB(22,23,27)
                currentKeyLabel.Font = Enum.Font.GothamSemibold
                currentKeyLabel.TextColor3 = Color3.fromRGB(255,255,255)
                Instance.new("UICorner", currentKeyLabel).CornerRadius = UDim.new(0,4)
                
                local default_keycode_name = type(options.keycode) == "EnumItem" and options.keycode.Name or "None"
                local current_keycode_name = Library.Flags[options.flag] or default_keycode_name
                Library.Flags[options.flag] = current_keycode_name
                currentKeyLabel.Text = current_keycode_name

                currentKeyLabel.MouseButton1Click:Connect(function()
                    currentKeyLabel.Text = "..."
                    local inputObject, processed = UserInputService.InputBegan:Wait()
                    if inputObject and inputObject.KeyCode ~= Enum.KeyCode.Unknown then
                        Library.Flags[options.flag] = inputObject.KeyCode.Name
                        currentKeyLabel.Text = inputObject.KeyCode.Name
                        Library:save_flags()
                    else
                        currentKeyLabel.Text = Library.Flags[options.flag] -- Revert if no valid key
                    end
                end)
                table.insert(Library.connections, currentKeyLabel.MouseButton1Click)

                local keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                    if gameProcessed then return end
                    if input.KeyCode.Name == Library.Flags[options.flag] then
                        if options.callback then pcall(options.callback, Library.Flags[options.flag]) end
                    end
                end)
                table.insert(Library.connections, keybindConnection)
            end

            return Module
        end

        -- Initial state: UI should be visible as Library.Enabled is true
        -- Call Library:open to ensure it's fully set up if needed, or rely on default visibility.
        -- Forcing an open here ensures the animations and Visible flags are set by the lib's own logic.
        if Library.Enabled then
             Library.open(Library.core) -- Pass the screenGui instance
        end

        return Tab -- This is the object that has the :create_tab method
    end

    return Library -- FIXED: Return the main Library table
end -- End of Library_Definition_Function

-- Execute the definition function to get the Library table
local Library = Library_Definition_Function()

-- Fallback if library definition failed
if not Library then
    warn("Critical error: Aries UI Library could not be defined. UI will not load.")
    return
end

--[[-----------------------------------------------------------------------------------------
    UI Definition Script (Using the Library above)
-------------------------------------------------------------------------------------------]]

-- Проверка, была ли библиотека успешно загружена (опционально, но рекомендуется)
if not Library or type(Library.new) ~= "function" then
    warn("UI Library not loaded or is invalid after definition. Halting script.")
    return -- Остановить выполнение, если библиотека не загружена
end

local MainUI = Library:new() -- Создает главное окно UI

if not MainUI or type(MainUI.create_tab) ~= "function" then
    warn("Failed to create MainUI or MainUI does not have create_tab method. Halting script.")
    return
end

-- -- Combat Tab Section
local CombatTab = MainUI:create_tab("Combat")

if CombatTab then
    -- Aimbot Toggle
    CombatTab:create_toggle({
        name = "Aimbot",
        flag = "AimbotEnabled", -- Флаг для сохранения состояния
        enabled = false, -- Состояние по умолчанию
        section = "left", -- 'left' или 'right' секция
        callback = function(state)
            print("Aimbot is now: " .. tostring(state))
            if state then
                -- Aimbot включен
            else
                -- Aimbot выключен
            end
        end
    })

    -- FOV Circle Slider
    CombatTab:create_slider({
        name = "FOV Circle",
        flag = "FovCircleSize",
        value = 90, -- Значение по умолчанию
        minimum_value = 30,
        maximum_value = 200,
        section = "right",
        callback = function(value)
            print("FOV Circle size: " .. tostring(value))
            -- Например, обновление визуального отображения круга FOV
        end
    })
else
    warn("Failed to create CombatTab.")
end

-- -- Movement Tab Section
local MovementTab = MainUI:create_tab("Movement")

if MovementTab then
    -- Speed Hack Toggle
    MovementTab:create_toggle({
        name = "Speed Hack",
        flag = "SpeedHackEnabled",
        enabled = false,
        section = "left",
        callback = function(state)
            print("Speed Hack is now: " .. tostring(state))
            -- if state then
            --     if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            --         LocalPlayer.Character.Humanoid.WalkSpeed = 100
            --     end
            -- else
            --     if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            --         LocalPlayer.Character.Humanoid.WalkSpeed = 16 -- стандартная скорость
            --     end
            -- end
        end
    })

    -- Jump Power Dropdown
    MovementTab:create_dropdown({
        name = "Jump Power",
        flag = "JumpPowerSetting",
        option = "Normal", -- Выбранный элемент по умолчанию
        options = {"Low", "Normal", "High", "Super"}, -- Список опций
        section = "right",
        callback = function(option)
            print("Jump Power set to: " .. option)
            -- local humanoid = LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            -- if humanoid then
            --     if option == "Low" then
            --         humanoid.JumpPower = 30
            --     elseif option == "Normal" then
            --         humanoid.JumpPower = 50 
            --     elseif option == "High" then
            --         humanoid.JumpPower = 75
            --     elseif option == "Super" then
            --         humanoid.JumpPower = 100
            --     end
            -- end
        end
    })

    -- Custom Speed Textbox
    MovementTab:create_textbox({
        name = "Custom Speed", -- Это будет placeholder текст
        flag = "CustomSpeedValue",
        value = "50", -- Текст по умолчанию / сохраненное значение
        section = "left",
        callback = function(text)
            print("Custom Speed entered: " .. text)
            -- local speed = tonumber(text)
            -- local humanoid = LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            -- if speed and humanoid then
            --     humanoid.WalkSpeed = speed
            -- else
            --     print("Invalid speed value entered for Custom Speed.")
            -- end
        end
    })

    -- Toggle Fly Keybind
    MovementTab:create_keybind({
        name = "Toggle Fly",
        flag = "FlyKeybind",
        keycode = Enum.KeyCode.F, -- Клавиша по умолчанию (F)
        section = "right",
        callback = function(key_name) 
            print("Fly toggled with key: " .. key_name)
            -- getgenv().FlyEnabled = not getgenv().FlyEnabled
            -- print("Fly state: ", getgenv().FlyEnabled)
        end
    })
else
    warn("Failed to create MovementTab.")
end

print("Aries UI Script Loaded. Press Insert to toggle UI.")

